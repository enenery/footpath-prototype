<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8" />
    <title>FootPath Prototype</title>
    <script src="phaser.min.js"></script>
</head>
<body>
    <div id="gamecontainer"></div>
    <script>
        "use strict"

        const GAMEWIDTH = 1000;
        const GAMEHEIGHT = 500;
        const PADDING = 10;
        const PATHNUMBERSTEPS = 50;
        const PATHSTEPLENGTH = 30;
        const USERSTEPERROR = 20;
        const USERANGLEERROR = 1.5;
        const EPSILON = 15;
        const ANGLECHANGE = Math.PI / 4;
        const INITX = 20;
        const INITY = 20;
        const NUMUNIFORMVARS = 6;

        let pathLines, pathPoints, cornerPoints, userPoints, userLines; 
        let userSprite, userPathIndex;
  
        /*
        * Approximates a Standard Normal Random Variable 
        *   by Averaging 6 Uniform Random Variables
        *   and subtracting 0.5
        * 
        * @method
        * @return{Number}
        */
        let normalRandom = function() {
            let uniformRandomSum = 0;
            for (let i = 0; i < NUMUNIFORMVARS; i++) {
                uniformRandomSum += Math.random();
            }
            let normalRandomNumber = (uniformRandomSum / NUMUNIFORMVARS) - 0.5;
            return normalRandomNumber;
        }

        /* 
        * Gives the probabilities that the Path should go 45 degrees left, 45 degrees right or straight
        *   at each step
        *
        * @method
        * @return{Number} - Angle Value
        */
        let angleChange = function() {
            let rnumber = Math.random();
            if (rnumber < 0.05) { return -Math.PI / 4; }
            else if (rnumber > 0.95) { return Math.PI / 4; }
            else { return 0; }
        }
 
        /* 
        * Checks to see whether the x and y coordinates are within world bounds
        *
        * @method
        * @return{Boolean}
        */
        let withinWorldBounds = function(x, y) {
            if (x < PADDING)              { return false; }
            if (x > GAMEWIDTH - PADDING)  { return false; }
            if (y < PADDING)              { return false; }
            if (y > GAMEHEIGHT - PADDING) { return false; }
            return true;
        }
        
        /* 
        * Generates the ideal path for the FootPath Algorithm
        *
        * @method
        * @return{Array of Phaser Points}
        */   
        let generatePathPoints = function(initX, initY) {
            let points = Array(), nextX, nextY;
            let currentX = initX; 
            let currentY = initY; 
            let currentAngle = 0;
            points.push( new Phaser.Point(currentX,currentY) );
            for (let i = 1; i <= PATHNUMBERSTEPS; i++) {
                let nextAngle = currentAngle + angleChange()
                nextX = currentX + Math.round( PATHSTEPLENGTH*Math.cos(nextAngle) );
                nextY = currentY + Math.round( PATHSTEPLENGTH*Math.sin(nextAngle) ); 
                while (!withinWorldBounds(nextX, nextY)) {
                    nextAngle += ANGLECHANGE;
                    nextX = currentX + Math.round( PATHSTEPLENGTH*Math.cos(nextAngle) );
                    nextY = currentY + Math.round( PATHSTEPLENGTH*Math.sin(nextAngle) ); 
                }
                currentX = nextX;
                currentY = nextY;
                currentAngle = nextAngle;
                points.push( new Phaser.Point(currentX,currentY) );
            } 
            return points;
        }

        /*
        * Takes in an array of Phaser Points and generates a Phaser line between every two points 
        *
        * @method
        * @return{Array of Phaser Lines}
        */
        let getLines = function(points) {
            let lines = Array();
            for (let i = 0; i < points.length-1; i++) {
                lines.push( new Phaser.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y) );
            }
            return lines;
        }
         
        /*
        * Takes in array of Phaser Points and array of Phaser Lines and creates a
        *   subset of the array of points that includes only corners
        *
        * @method
        * @return{Array of Phaser Points}
        */ 
        let getPathCorners = function(points, lines) {
            let angle = lines[0].angle;
            let pathCorners = Array();
            for (let i = 0; i < PATHNUMBERSTEPS; i++) {
                if (lines[i].angle != angle) {
                    pathCorners.push(points[i]);
                    angle = lines[i].angle;
                }
            }
            pathCorners.push(points[PATHNUMBERSTEPS]);
            return pathCorners;
        }
            
        /*
        * Generates a path that the user takes, which is more noisy than the ideal path
        *
        * @method
        * @result{Array of Phaser Points}
        */
        let generateUserMovement = function(initX, initY, cornerPoints) {
            let userMovementArray = Array();
            let cornerIndex = 0, distance, userStepLength, nextX = -1, nextY = -1;
            let currentUserPosition = new Phaser.Point(initX, initY); 
            userMovementArray.push(currentUserPosition);
            while (cornerIndex < cornerPoints.length) {
                let distance = Phaser.Point.distance(cornerPoints[cornerIndex], currentUserPosition);
                if (distance > PATHSTEPLENGTH) {
                    userStepLength = Math.round( PATHSTEPLENGTH + USERSTEPERROR*normalRandom() );
                } 
                else if (distance > EPSILON) {
                    userStepLength = Math.round( distance + normalRandom() );
                }
                else {
                    cornerIndex++;
                    continue;
                } 
                let angle = Phaser.Point.angle(cornerPoints[cornerIndex], currentUserPosition) + USERANGLEERROR*normalRandom();
                nextX = currentUserPosition.x + userStepLength*Math.cos(angle);
                nextY = currentUserPosition.y + userStepLength*Math.sin(angle);
                while (!withinWorldBounds(nextX, nextY)) {
                    let angle = Phaser.Point.angle(cornerPoints[cornerIndex], currentUserPosition) + USERANGLEERROR*normalRandom();
                    nextX = currentUserPosition.x + userStepLength*Math.cos(angle);
                    nextY = currentUserPosition.y + userStepLength*Math.sin(angle);
                }
                currentUserPosition = new Phaser.Point(nextX, nextY);
                userMovementArray.push(currentUserPosition);
            }

            return userMovementArray;                
        }
 
        let footpathEstimate = function(sprite, userLines, userPathIndex, pathLines, userPathIndex) {
            

        }

        let game = new Phaser.Game(GAMEWIDTH, GAMEHEIGHT, Phaser.AUTO, "gamecontainer");
 
        let ProtoType = {
            preload: function() {
               game.load.image("userSprite", "navigation.png"); 
            },
            create: function() {
                
                game.stage.backgroundColor = "#124126"
                pathPoints = generatePathPoints(INITX, INITY);
                pathLines = getLines(pathPoints);
                cornerPoints = getPathCorners(pathPoints, pathLines);
                userPoints = generateUserMovement(INITX, INITY, cornerPoints);
                userLines = getLines(userPoints);

                userSprite = game.add.sprite(userPoints[0].x, userPoints[0].y, "userSprite");
                userSprite.anchor = new Phaser.Point(0.5, 0.5);
                userSprite.width = 30;
                userSprite.height = 30;
                userSprite.rotation += Math.PI / 4 + 0.1; // Correction Term
                userSprite.rotation += userLines[0].angle;  
                userPathIndex = 0;             
 
            },
            update: function() {

            },
            render: function() {
                for (let i = 0; i < PATHNUMBERSTEPS; i++) { 
                    game.debug.geom(pathLines[i], "rgba(0,200,0,1)");
                    game.debug.geom(pathPoints[i], "rgba(0,200,0,1)");
                }
                
                game.debug.geom(pathPoints[PATHNUMBERSTEPS]);
                
                for (let i = 0 ; i < cornerPoints.length; i++) {
                    game.debug.geom(cornerPoints[i], "rgba(0,200,200,1)");
                }

                for (let i = 0; i < userLines.length; i++) { 
                    game.debug.geom(userLines[i], "rgba(200,200,0,1)");
                    game.debug.geom(userPoints[i], "rgba(200,200,0,1)");
                }
                game.debug.geom(userPoints[userLines.length], "rgba(200,200,0,1)");
            },
            updateUser: function() {
                if (userPathIndex < userPoints.length) {
                    userPathIndex++;
                    userSprite.x = userPoints[userPathIndex].x;
                    userSprite.y = userPoints[userPathIndex].y;
                    if (userPathIndex >= 2) {
                        userSprite.rotation -= userLines[userPathIndex-2].angle;
                        userSprite.rotation += userLines[userPathIndex-1].angle;
                    }
                }
            }
        };

        game.state.add("ProtoType", ProtoType);    
        game.state.start("ProtoType");
        
    </script>
    <br />
    <button onclick="ProtoType.updateUser()">User Move</button>
</body>
</html>
