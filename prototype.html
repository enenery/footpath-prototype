<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8" />
    <title>FootPath Prototype</title>
    <script src="phaser.min.js"></script>
</head>
<body>
    <div id="gamecontainer"></div>
    <script>
        "use strict"

        const GAMEWIDTH = 1000;
        const GAMEHEIGHT = 500;
        const PADDING = 10;
        const PATHNUMBERSTEPS = 50;
        const PATHSTEPLENGTH = 30;
        const USERSTEPERROR = 20;
        const USERANGLEERROR = 1.5;
        const EPSILON = 15;
        const ANGLECHANGE = Math.PI / 4;
        const INITX = 20;
        const INITY = 20;
        const NUMUNIFORMVARS = 6;

        let pathLines, pathPoints, cornerPoints, userPoints, userLines; 
        let userSprite, userPathIndex;
        let footpathSprite, footpathIndex;
  
        /*
        * Approximates a Standard Normal Random Variable 
        *   by Averaging 6 Uniform Random Variables
        *   and subtracting 0.5
        * 
        * @method
        * @return{Number}
        */
        let normalRandom = function() {
            let uniformRandomSum = 0;
            for (let i = 0; i < NUMUNIFORMVARS; i++) {
                uniformRandomSum += Math.random();
            }
            let normalRandomNumber = (uniformRandomSum / NUMUNIFORMVARS) - 0.5;
            return normalRandomNumber;
        };

        /* 
        * Gives the probabilities that the Path should go 45 degrees left, 45 degrees right or straight
        *   at each step
        *
        * @method
        * @return{Number} - Angle Value
        */
        let angleChange = function() {
            let rnumber = Math.random();
            if (rnumber < 0.05) { return -Math.PI / 4; }
            else if (rnumber > 0.95) { return Math.PI / 4; }
            else { return 0; }
        };
 
        /* 
        * Checks to see whether the x and y coordinates are within world bounds
        *
        * @method
        * @return{Boolean}
        */
        let withinWorldBounds = function(x, y) {
            if (x < PADDING)              { return false; }
            if (x > GAMEWIDTH - PADDING)  { return false; }
            if (y < PADDING)              { return false; }
            if (y > GAMEHEIGHT - PADDING) { return false; }
            return true;
        };
        
        /* 
        * Generates the ideal path for the FootPath Algorithm
        *
        * @method
        * @return{Array of Phaser Points}
        */   
        let generatePathPoints = function(initX, initY) {
            let points = Array(), nextX, nextY;
            let currentX = initX; 
            let currentY = initY; 
            let currentAngle = 0;
            points.push( new Phaser.Point(currentX,currentY) );
            for (let i = 1; i <= PATHNUMBERSTEPS; i++) {
                let nextAngle = currentAngle + angleChange()
                nextX = currentX + Math.round( PATHSTEPLENGTH*Math.cos(nextAngle) );
                nextY = currentY + Math.round( PATHSTEPLENGTH*Math.sin(nextAngle) ); 
                while (!withinWorldBounds(nextX, nextY)) {
                    nextAngle += ANGLECHANGE;
                    nextX = currentX + Math.round( PATHSTEPLENGTH*Math.cos(nextAngle) );
                    nextY = currentY + Math.round( PATHSTEPLENGTH*Math.sin(nextAngle) ); 
                }
                currentX = nextX;
                currentY = nextY;
                currentAngle = nextAngle;
                points.push( new Phaser.Point(currentX,currentY) );
            } 
            return points;
        };

        /*
        * Takes in an array of Phaser Points and generates a Phaser line between every two points 
        *
        * @method
        * @return{Array of Phaser Lines}
        */
        let getLines = function(points) {
            let lines = Array();
            lines.push( new Phaser.Line(0,0,0,0) ); // Degenerate Line Placeholder for index 0
            for (let i = 0; i < points.length-1; i++) {
                lines.push( new Phaser.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y) );
            }
            return lines;
        };
         
        /*
        * Takes in array of Phaser Points and array of Phaser Lines and creates a
        *   subset of the array of points that includes only corners
        *
        * @method
        * @return{Array of Phaser Points}
        */ 
        let getPathCorners = function(points, lines) {
            let angle = lines[1].angle;
            let pathCorners = Array();
            for (let i = 1; i <= PATHNUMBERSTEPS; i++) {
                if (lines[i].angle != angle) {
                    pathCorners.push(points[i]);
                    angle = lines[i].angle;
                }
            }
            pathCorners.push(points[PATHNUMBERSTEPS]);
            return pathCorners;
        };
            
        /*
        * Generates a path that the user takes, which is more noisy than the ideal path
        *
        * @method
        * @result{Array of Phaser Points}
        */
        let generateUserMovement = function(initX, initY, cornerPoints) {
            let userMovementArray = Array();
            let cornerIndex = 0, distance, userStepLength, nextX = -1, nextY = -1;
            let currentUserPosition = new Phaser.Point(initX, initY); 
            userMovementArray.push(currentUserPosition);
            while (cornerIndex < cornerPoints.length) {
                let distance = Phaser.Point.distance(cornerPoints[cornerIndex], currentUserPosition);
                if (distance > PATHSTEPLENGTH) {
                    userStepLength = Math.round( PATHSTEPLENGTH + USERSTEPERROR*normalRandom() );
                } 
                else if (distance > EPSILON) {
                    userStepLength = Math.round( distance + normalRandom() );
                }
                else {
                    cornerIndex++;
                    continue;
                } 
                let angle = Phaser.Point.angle(cornerPoints[cornerIndex], currentUserPosition) + USERANGLEERROR*normalRandom();
                nextX = currentUserPosition.x + userStepLength*Math.cos(angle);
                nextY = currentUserPosition.y + userStepLength*Math.sin(angle);
                while (!withinWorldBounds(nextX, nextY)) {
                    let angle = Phaser.Point.angle(cornerPoints[cornerIndex], currentUserPosition) + USERANGLEERROR*normalRandom();
                    nextX = currentUserPosition.x + userStepLength*Math.cos(angle);
                    nextY = currentUserPosition.y + userStepLength*Math.sin(angle);
                }
                currentUserPosition = new Phaser.Point(nextX, nextY);
                userMovementArray.push(currentUserPosition);
            }

            return userMovementArray;                
        };
 
        let generateInitDPTable = function(pathLines) {
            let dpTable = Array();
            dpTable.push(0); 
            for (let i = 0; i <= PATHNUMBERSTEPS; i++) {
                dpTable.push(Infinity);
            }
            return dpTable;
        };

        let scoreFunction = function(firstAngle, secondAngle) {
            let radianDifference = Math.abs(firstAngle - secondAngle);
            let degreeDifference = radianDifference * 180 / Math.PI;
            if (degreeDifference <= 45) {
                return 0;
            } else if (degreeDifference <= 90) {
                return 1;
            } else if (degreeDifference <= 120) {
                return 2;
            } else {
                return 10;
            }
        }

        let updateDPTable = function(dpTable, userLines, userIndex, pathLines) {
            let newDPTable = Array();
            newDPTable.push(Infinity);
            let j = userIndex;
            for (let i = 1; i <= PATHNUMBERSTEPS; i++) {
                let firstScore = dpTable[i-1] + scoreFunction(userLines[j].angle, pathLines[i].angle);
                let secondScore = newDPTable[i-1] 
                                + scoreFunction(userLines[j-1].angle, pathLines[i].angle) + 1.5;
                let thirdScore = dpTable[i+1] + scoreFunction(userLines[j].angle, pathLines[i-1].angle) + 1.5; 
            
                let score = Math.min(firstScore, secondScore, thirdScore)
                newDPTable.push(score);
            }
            return newDPTable;
        }

        let footpathEstimate = function(dpTable) {
            let optimalPathIndex = 0;
            for (let i = 0; i < dpTable.length; i++) {
                if (dpTable[i] < dpTable[optimalPathIndex]) {
                    optimalPathIndex = i;
                }
            } 
            return optimalPathIndex;
        }

        let game = new Phaser.Game(GAMEWIDTH, GAMEHEIGHT, Phaser.AUTO, "gamecontainer");
 
        let ProtoType = {
            preload: function() {
                game.load.image("userSprite", "navigation.png");
                game.load.image("footpathSprite", "navigation2.png"); 
            },
            create: function() {
                
                game.stage.backgroundColor = "#124126"
                pathPoints = generatePathPoints(INITX, INITY);
                pathLines = getLines(pathPoints);
                cornerPoints = getPathCorners(pathPoints, pathLines);
                userPoints = generateUserMovement(INITX, INITY, cornerPoints);
                userLines = getLines(userPoints);

                footpathSprite = game.add.sprite(pathPoints[0].x, pathPoints[0].y, "footpathSprite");
                footpathSprite.anchor = new Phaser.Point(0.5, 0.5);
                footpathSprite.width = 30;
                footpathSprite.height = 30;
                footpathSprite.rotation += Math.PI / 4 + 0.1;
                footpathSprite.rotation += pathLines[1].angle;
                
                footpathIndex = 0;

                userSprite = game.add.sprite(userPoints[0].x, userPoints[0].y, "userSprite");
                userSprite.anchor = new Phaser.Point(0.5, 0.5);
                userSprite.width = 30;
                userSprite.height = 30;
                userSprite.rotation += Math.PI / 4 + 0.1; // Correction Term
                userSprite.rotation += userLines[1].angle;
                
                userPathIndex = 0;
 
            },
            update: function() {

            },
            render: function() {
                game.debug.geom(pathPoints[0], "rgba(0,200, 0, 1)");
                for (let i = 1; i <= PATHNUMBERSTEPS; i++) { 
                    game.debug.geom(pathLines[i], "rgba(0,200,0,1)");
                    game.debug.geom(pathPoints[i], "rgba(0,200,0,1)");
                }
                
                for (let i = 0 ; i < cornerPoints.length; i++) {
                    game.debug.geom(cornerPoints[i], "rgba(0,200,200,1)");
                }

                game.debug.geom(userPoints[0], "rgba(200,200,0,1)");
                for (let i = 1; i <= userLines.length; i++) { 
                    game.debug.geom(userLines[i], "rgba(200,200,0,1)");
                    game.debug.geom(userPoints[i], "rgba(200,200,0,1)");
                }
            },
            updateUser: function() {
                if (userPathIndex < userPoints.length) {
                    userPathIndex++;
                    userSprite.x = userPoints[userPathIndex].x;
                    userSprite.y = userPoints[userPathIndex].y;
                    if (userPathIndex >= 2) {
                        userSprite.rotation -= userLines[userPathIndex-1].angle;
                        userSprite.rotation += userLines[userPathIndex].angle;
                    }
                }
            },
            footPathEstimate: function() {

            }
        
        };

        game.state.add("ProtoType", ProtoType);    
        game.state.start("ProtoType");
        
    </script>
    <br />
    <button onclick="ProtoType.updateUser()">User Move</button>
    <!-- <br />
    <button onclick="" -->
</body>
</html>
